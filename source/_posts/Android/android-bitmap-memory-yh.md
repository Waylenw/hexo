title: Android bitmap优化
tags:
- Android
---
 # 内存溢出的原由

> 内存溢出：就是分配的内存不足以放下数据项序列。如在一个域中输入的数据超过了它的要求
就会系统能给你的，系统不能满足需求，于是产生溢出。或者可以这样理解堆上分配的内存没
有被释放，从而失去对其控制。这样会造成程序能使用的内存越来越少，导致系统运行速度减
慢，严重情况会使程序宕掉。

 ## 了解BitMap和内存的关系
 ### 位图和矢量图的区别
 - 位图
  位图使用我们称为像素的一格一格的小点来描述图像.您的计算机屏幕其实就是一张包含大量像素点的网格.在位图中,上面我们看到的树叶图像将会由每一个网格中的像素点的位置和色彩值来决定.每一点的色彩是固定的,当我们在更高分辨率下观看图像时,每一个小点看上去就像是一个个马赛克色块,如下面例子中的右图.
  当您在进行位图编辑时,其实您是在一点一点的定义图像中的所有像素点的信息,而不是类似矢量图只需要定义图形的轮廓线段和曲线.因为一定尺寸的位图图像是在一定分辨率下被一点一点记录下来,所以这些位图图像的品质是和图像生成时采用的分辨率相关的.当图像放大后,会在图像边缘出
 - 矢量图
 矢量图使用线段和曲线描述图像,所以称为矢量,同时图形也包含了色彩和位置信息.下面例子中的树叶,就是利用大量的点连接成曲线来描述树叶的轮廓线.然后根据轮廓线,在图像内部填充一定的色彩.
 当您进行矢量图形的编辑时,您定义的是描述图形形状的线和曲线的属性,这些属性将被记录下来.对矢量图形的操作,例如移动,重新定义尺寸,重新定义形状,或者改变矢量图形的色彩,都不会改变矢量图形的显示品质.您也可以通过矢量对象的交叠,使得图形的某一部分被隐藏,或者改变对象的透明度.矢量图形是"分辨率独立"的,这就是说,当您显示或输出图像时,图像的品质不受设备的分辨率的影响.在例子中,右图是放大后的矢量图形,我们看见图像的品质没有受到影响.
    
 - 总结
 他们最简单的区别就是:
 失量图可以无限放大.而且不会失真.
 ### Bitmap占用大小和内存的关系
   由上描素可知。Bitmap的是属于位图，而影响位图的占用大小的几个关键点：
   
 - 图片长度
 - 图片宽度
 - 每个像素所占的字节(Bitmap的RGB值) 

所以BitMap的的计算公式为:
一张图片（BitMap）占用的内存=图片长度*图片宽度*单位像素占用的字节数
[详解介绍如何计算Bitmap内存占用](http://blog.csdn.net/hudashi/article/details/7856519)

 **注意：**
        Bitmap的占用空间大小和目标文件的大小无关，主要是图片的长和宽。
        
 # Bitmap的优化

 > 引用块内容注意 ：在Android应用里，最耗费内存的就是图片资源。而且在Android系统中，读取位图Bitmap时，分给虚拟机中的图片的堆栈大只有8M，如果超出了，就会出现OutOfMemory异常。

 ## 1.及时释放内存

 ### 1.1为什么要及时回收Bitmap的内存
   Bitmap类有一个方法recycle()，从方法名可以看出意思是回收。这里就有疑问了，Android系统有自己的垃圾回收机制，可以不定期的回收掉不使用的内存空间，当然也包括Bitmap的空间。那为什么还需要这个方法呢？
 Bitmap类的构造方法都是私有的，所以开发者不能直接new出一个Bitmap对象，只能通过BitmapFactory类的各种静态方法来实例化一个Bitmap。仔细查看BitmapFactory    的源代码可以看到，生成Bitmap对象最终都是通过JNI调用方式实现的。所以，加载Bitmap到内存里以后，是包含两部分内存区域    的。简单的说，一部分是Java部分的，一部分是C部分的。这个Bitmap对象是由Java部分分配的，不用的时候系统就会自动回收了，但是那个对应的C可用的内存区域，虚拟机是不能直接回收的，这个只能调用底层的功能释放。所以需要调用recycle()方法来释放C部分的内存。从Bitmap类的源代码也可以看到，recycle()方法里也的确是调用了JNI方法了。
  那如果不调用recycle()，是否就一定存在内存泄露呢？也不是的。Android的每个应用都运行在独立的进程里，有着独立的内存，如  果整个进程被应用本身或者系统杀死了，内存也就都被释放掉了，当然也包括C部分的内存。
  Android对于进程的管理是非常复杂的。简单的说，Android系统的进程分为几个级别，系统会在内存不足的情况下杀死一些低优先  级的进程，以提供给其它进程充足的内存空间。在实际项目开发过程中，有的开发者会在退出程序的时候使用  Process.killProcess(Process.myPid())的方式将自己的进程杀死，但是有的应用仅仅会使用调用Activity.finish()方法的方式关闭掉所有的Activity。

 ### 1.2手动释放内存

Android手机的用户，根据习惯不同，可能会有两种方式退出整个应用程序：一种是按Home键直接退到桌面；另一种是从应用程序的退出按钮或者按Back键退出程序。那么从系统的角度来说，这两种方式有什么区别呢？按Home键，应用程序并没有被关闭，而是成为了后台应用程序。按Back键，一般来说，应用程序关闭了，但是进程并没有被杀死，而是成为了空进程（程序本身对退出做了特殊处理的不考虑在内）。
Android系统已经做了大量进程管理的工作，这些已经可以满足用户的需求。个人建议，应用程序在退出应用的时候不需要手动杀死自己所在的进程。对于应用程序本身的进程管理，交给Android系统来处理就可以了。应用程序需要做的，是尽量做好程序本身的内存管理工作。
 
一般来说，如果能够获得Bitmap对象的引用，就需要及时的调用Bitmap的recycle()方法来释放Bitmap占用的内存空间，而不要等Android系统来进行释放。
下面是释放Bitmap的示例代码片段。
```
//在Activity或Fragment的onDestory方法中进行回收(必须确保bitmap不在使用)
public void onDestory(){
     // 先判断是否已经回收
	if(bitmap != null && !bitmap.isRecycled()){ 
        // 回收并且置为null
        bitmap.recycle(); 
        bitmap = null; 
	} 
}
```
从上面的代码可以看到，bitmap.recycle()方法用于回收该Bitmap所占用的内存，接着将bitmap置空，最后使用System.gc()调用一下系统的垃圾回收器进行回收，可以通知垃圾回收器尽快进行回收。这里需要注意的是，调用System.gc()并不能保证立即开始进行回收过程，而只是为了加快回收的到来。

 ## 2.进行图片压缩
  在上诉几种方法做完之后，是否还有问题？如果我在开始的时候加载一张很大的图，直接超过了分配的内存大小，那也会引起内存溢出。这个时候我们就需要对加载的BitMap的大小进行控制，这个时候就需要用到图片压缩。
 - [图片压缩比较靠谱的几种办法](http://www.cnblogs.com/xiaochao1234/p/3880402.html)
 
 ## 3.捕获异常
因为Bitmap是吃内存大户，为了避免应用在分配Bitmap内存的时候出现OutOfMemory异常以后Crash掉，需要特别注意实例化Bitmap部分的代码。通常，在实例化Bitmap的代码中，一定要对OutOfMemory异常进行捕获。

以下是代码示例。

 ```
Bitmap bitmap = null;  
try { 
    // 实例化Bitmap 
    bitmap = BitmapFactory.decodeFile(path); 
} catch (OutOfMemoryError e) { 
    // 
} 
 ```
这里对初始化Bitmap对象过程中可能发生的OutOfMemory异常进行了捕获。如果发生了OutOfMemory异常，应用不会崩溃，而是得到了一个默认的Bitmap图。

 > 经验分享：
 > 很多开发者会习惯性的在代码中直接捕获Exception。但是对于OutOfMemoryError来说，这样做是捕获不到的。因为OutOfMemoryError是一种Error，而不是Exception。在此仅仅做一下提醒，避免写错代码而捕获不到OutOfMemoryError。

                            
    
  
 


